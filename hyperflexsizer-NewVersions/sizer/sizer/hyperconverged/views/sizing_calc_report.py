# coding: utf-8
""" This script generates PPT """
import sys
import logging
import json
import datetime
import os
import math
import copy

from math import ceil
from collections import OrderedDict
from collections import defaultdict
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.chart.data import ChartData
from pptx.enum.chart import XL_CHART_TYPE
from pptx.enum.chart import XL_LABEL_POSITION
from pptx.enum.chart import XL_LEGEND_POSITION
from pptx.enum.chart import XL_TICK_MARK
from pptx.enum.text import MSO_ANCHOR, MSO_AUTO_SIZE
from pptx.enum.chart import XL_TICK_LABEL_POSITION
from pptx.dml.color import RGBColor
from pptx.enum.shapes import MSO_SHAPE
from pptx.enum.dml import MSO_THEME_COLOR
from pptx.enum.shapes import MSO_SHAPE_TYPE
from pptx.enum.text import PP_ALIGN
from pptx.enum.text import MSO_ANCHOR, MSO_AUTO_SIZE

from hyperconverged.solver.attrib import HyperConstants
from sizer.local_settings import BASE_DIR

import gettext
# from importlib import reload
# reload(sys)
# #sys.setdefaultencoding('utf8')

appname = "base"
dir = os.path.join(BASE_DIR, "sizer/locales")
# dir = "./locales"
gettext.install(appname, dir)

languages = {
    "english": gettext.translation(appname, dir, languages=["en"]),
    "japanese": gettext.translation(appname, dir, languages=["ja"])
}

_ = languages["english"].gettext

ENGLISH = "english"
JAPANESE = "japanese"

FULL_CAPACITY = 3

class Report(object):

    def __init__(self, s_data):
        self.scenario_data = json.loads(s_data)


class PPTCALCReport(Report):
    SLIDEMASTER_TITLE_LAYOUT_INDEX=0;
    SLIDEMASTER_SECTION_LAYOUT_INDEX=1;
    SLIDEMASTER_BULLET_LAYOUT_INDEX=2;
    SLIDEMASTER_BOX_LAYOUT_INDEX=5;
    SLIDEMASTER_BLANK_LAYOUT_INDEX=6;
    SLIDEMASTER_BIG_STMT_LAYOUT_INDEX=8;
    SLIDEMASTER_BACKUP_LAYOUT_INDEX=10;
    SLIDEMASTER_LAST_LAYOUT_INDEX=11;
    SLIDEMASTER_VDI_CALC_LAYOUT_INDEX=17;
    SLIDEMASTER_CALC_LAYOUT_INDEX=18;
    SLIDEMASTER_NODECALC_LAYOUT_INDEX1=19;
    SLIDEMASTER_NODECALC_LAYOUT_INDEX2=20;
    SLIDEMASTER_RAW_CALC_LAYOUT_INDEX=21;
    SLIDEMASTER_FIVE_BOX_LAYOUT_INDEX = 23;

    SLIDEMASTER_OVERVIEW_LAYOUT_INDEX_1=12
    SLIDEMASTER_OVERVIEW_LAYOUT_INDEX_2=13
    SLIDEMASTER_OVERVIEW_LAYOUT_INDEX_3=14
    SLIDEMASTER_OVERVIEW_LAYOUT_INDEX_4=15
    SLIDEMASTER_OVERVIEW_LAYOUT_INDEX_5=16
    SLIDEMASTER_OVERVIEW_LAYOUT_INDEX_6=17

    SLIDEMASTER_OVERVIEW_LAYOUT_JA_INDEX_1 = 24
    SLIDEMASTER_OVERVIEW_LAYOUT_JA_INDEX_2 = 25
    SLIDEMASTER_OVERVIEW_LAYOUT_JA_INDEX_3 = 26
    SLIDEMASTER_OVERVIEW_LAYOUT_JA_INDEX_4 = 27
    SLIDEMASTER_OVERVIEW_LAYOUT_JA_INDEX_5 = 28
    SLIDEMASTER_OVERVIEW_LAYOUT_JA_INDEX_6 = 29

    SLIDEMASTER_JA_GLOSSARY_INDEX = 30
    SLIDEMASTER_LAST_LAYOUT_INDEX_JA = 31

    def __init__(self, scenario_data):
        Report.__init__(self, scenario_data)

    def setup_calcreport(self):

        template_path = os.path.join(BASE_DIR, "sizer/hflexsizer_bom_template.pptx")
        self.prs = Presentation(template_path)
        self.report_name = None

    def createHeaderPage(self):
        prs=self.prs

        slide1 = prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_TITLE_LAYOUT_INDEX])
        title1 = slide1.shapes.title
        subhead = slide1.placeholders[13]
        customertext = slide1.placeholders[1]
        genbytext = slide1.placeholders[10]
        datetext = slide1.placeholders[11]
    
        title1.text  = _("Sizing Calculator Report")
        subhead.text = " "
        customertext.text = " "
        genbytext.text = _("Generated by") + ": " + self.scenario_data['username']
        currentdate = datetime.datetime.now().strftime('%Y-%m-%d')
        datetext.text = _("Date") + ": " + currentdate

        # SLIDE 2 - Disclaimer
        disclaimer_path = os.path.join(BASE_DIR, "sizer/disclaimer.txt")

        if self.language == JAPANESE:
            disclaimer_path = os.path.join(BASE_DIR, "sizer/disclaimer_ja.txt")

        with open(disclaimer_path, 'r', encoding='utf-8') as string_file:
            disclaimer_data = string_file.read()

        slide2 = prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_BLANK_LAYOUT_INDEX])
        shapes2 = slide2.shapes
        shapes2.title.text = _("Disclaimer")
        tbleft = Inches(0.26)
        tbtop = Inches(0.5)
        tbwidth = Inches(9.4)
        tbheight = Inches(4)
        tx_box = shapes2.add_textbox(tbleft, tbtop, tbwidth, tbheight)
        tx_box.text = disclaimer_data
        tx_box.text_frame.paragraphs[0].font.size = Pt(14)
        tx_box.text_frame.paragraphs[0].font.color.rgb = RGBColor(0x00, 0x00, 0x00)
        tx_box.text_frame.word_wrap = True
        tx_box.text_frame.paragraphs[0].alignment = PP_ALIGN.JUSTIFY
        tx_box.text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT


    def createAgendaPage(self):
        #SLIDE 3 - Agenda

        prs=self.prs
        slide2 = prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_BULLET_LAYOUT_INDEX])
        shapes2 = slide2.shapes

        title_shape = shapes2.title
        body_shape = shapes2.placeholders[10]
        title_shape.text = _("Content")

        tf = body_shape.text_frame
        tf.text = _('HyperFlex Product Overview')
        p = tf.add_paragraph()
        p.text = _('User Inputs')
        p = tf.add_paragraph()
        p.text = _('Results')
        p = tf.add_paragraph()
        p.text = _('Node Calculation')

    def createOverviewPage(self):
        prs=self.prs

        if self.language == JAPANESE:
            prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_OVERVIEW_LAYOUT_JA_INDEX_1])
            prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_OVERVIEW_LAYOUT_JA_INDEX_2])
            prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_OVERVIEW_LAYOUT_JA_INDEX_3])
            prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_OVERVIEW_LAYOUT_JA_INDEX_4])
            prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_OVERVIEW_LAYOUT_JA_INDEX_5])
            prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_OVERVIEW_LAYOUT_JA_INDEX_6])
        else:
            prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_OVERVIEW_LAYOUT_INDEX_1])
            prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_OVERVIEW_LAYOUT_INDEX_2])

            slide = prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_OVERVIEW_LAYOUT_INDEX_3])
            note_filepath = os.path.join(BASE_DIR, "sizer/slide_note3.txt")

            with open(note_filepath, 'r', encoding='utf-8') as string_file:
                notes = string_file.read()

            notes_slide = slide.notes_slide
            text_frame = notes_slide.notes_text_frame
            text_frame.text = notes

            slide = prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_OVERVIEW_LAYOUT_INDEX_4])
            note_filepath = os.path.join(BASE_DIR, "sizer/slide_note4.txt")

            with open(note_filepath, 'r', encoding='utf-8') as string_file:
                notes = string_file.read()

            notes_slide = slide.notes_slide
            text_frame = notes_slide.notes_text_frame
            text_frame.text = notes

            prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_OVERVIEW_LAYOUT_INDEX_5])

            slide = prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_OVERVIEW_LAYOUT_INDEX_6])
            note_filepath = os.path.join(BASE_DIR, "sizer/slide_note6.txt")

            with open(note_filepath, 'r', encoding='utf-8') as string_file:
                notes = string_file.read()

            notes_slide = slide.notes_slide
            text_frame = notes_slide.notes_text_frame
            text_frame.text = notes


    def get_sizing_configuration_fixedsizing(self):
        sizing_config_table = OrderedDict()

        sizing_config_table['header'] = ['Configuration', 'Description']
        sizing_config_per_row = []

        hx_version = self.scenario_data['settings_json'][0]['hx_version']
        sizing_config_per_row = []
        sizing_config_per_row.append('HXDP Version')
        sizing_config_per_row.append(str(hx_version))

        row_index = 0
        row_name = "row" + str(row_index)
        sizing_config_table[row_name] = sizing_config_per_row

        sizer_version = self.scenario_data['settings_json'][0]['sizer_version']
        sizing_config_per_row = []
        sizing_config_per_row.append('Sizer Version')
        sizing_config_per_row.append(str(sizer_version))

        row_index += 1
        row_name = "row" + str(row_index)
        sizing_config_table[row_name] = sizing_config_per_row

        settings_data = self.scenario_data['settings_json'][0]

        threshold = settings_data['threshold']
        if threshold == 0:
            thr_value =  'Conservative'
        elif threshold == 1:
            thr_value = 'Standard'
        elif threshold == 2:
            thr_value = 'Aggressive'
        else:
            thr_value = 'Full Capacity'

        sizing_config_per_row = []
        thresholdConf = "Threshold"
        sizing_config_per_row.append(thresholdConf)
        sizing_config_per_row.append(thr_value)

        row_index += 1
        row_name = "row" + str(row_index)
        sizing_config_table[row_name] = sizing_config_per_row


        return sizing_config_table

    def get_node_configuration_fixedsizing(self):
        node_config_table = OrderedDict()

        node_properties = self.scenario_data['node_properties']
        node_type = node_properties['nodeType']
        self.node_type = node_type
        nodetype = 'CTO' if node_type == 'cto' else 'Bundle'
        node_config_per_row = []
        node_config_per_row.append(_('Node Type'))
        node_config_per_row.append(nodetype)

        row_index = 0
        row_name = "row" + str(row_index)
        node_config_table[row_name] = node_config_per_row

        node_name = node_properties['node']
        node_config_per_row = []
        node_config_per_row.append(_('HyperFlex Node Type'))
        node_config_per_row.append(node_name)

        row_index += 1
        row_name = "row" + str(row_index)
        node_config_table[row_name] = node_config_per_row

        no_of_nodes = node_properties['no_of_nodes']
        self.no_of_nodes = no_of_nodes
        node_config_per_row = []
        node_config_per_row.append(_('No. of HyperFlex Nodes'))
        node_config_per_row.append(str(no_of_nodes))

        row_index += 1
        row_name = "row" + str(row_index)
        node_config_table[row_name] = node_config_per_row

        compute_node = node_properties['compute_node']
        self.compute_node = compute_node
        node_config_per_row = []
        node_config_per_row.append(_('Compute Node Type'))
        node_config_per_row.append(compute_node)

        row_index += 1
        row_name = "row" + str(row_index)
        node_config_table[row_name] = node_config_per_row

        no_of_computes = node_properties['no_of_computes']
        self.no_of_computes = no_of_computes
        node_config_per_row = []
        node_config_per_row.append(_('No. of Compute Nodes'))
        node_config_per_row.append(str(no_of_computes))

        row_index += 1
        row_name = "row" + str(row_index)
        node_config_table[row_name] = node_config_per_row

        cpu = "%s (%s, %s)" %(node_properties['cpu'][0].split(' ')[0], node_properties['cpu'][1], node_properties['cpu'][2])
        self.cpu = node_properties['cpu'][0]
        node_config_per_row = []
        node_config_per_row.append(_('CPU Type (Cores, GHz)'))
        node_config_per_row.append(cpu)

        row_index += 1
        row_name = "row" + str(row_index)
        node_config_table[row_name] = node_config_per_row

        ram_total = sum(node_properties['ram'][1] * ram_size for ram_size in node_properties['ram'][2])
        ram_str = ["%s * %sGiB" %(node_properties['ram'][1], ram_size) for ram_size in node_properties['ram'][2]]
        ram_calc_str = ' + '.join([str(v) for v in ram_str])
        ram = "%s [%s]" %(ram_total, ram_calc_str)
        ram_slots = [node_properties['ram'][1] * slot  for slot in node_properties['ram'][2]]
        self.ram = sum(ram_slots)
        node_config_per_row = []
        node_config_per_row.append(_('RAM per Node (GiB)'))
        node_config_per_row.append(str(ram))

        row_index += 1
        row_name = "row" + str(row_index)
        node_config_table[row_name] = node_config_per_row

        disks_per_node = node_properties['disks_per_node']
        self.disks_per_node = disks_per_node
        node_config_per_row = []
        node_config_per_row.append(_('No. of Disk Drives per Node'))
        node_config_per_row.append(str(disks_per_node))

        row_index += 1
        row_name = "row" + str(row_index)
        node_config_table[row_name] = node_config_per_row

        disk_capacity = node_properties['disk_capacity'][0]
        self.disk_capacity = disk_capacity
        node_config_per_row = []
        node_config_per_row.append(_('Disk Drive Size (GB)'))
        node_config_per_row.append(str(disk_capacity))

        row_index += 1
        row_name = "row" + str(row_index)
        node_config_table[row_name] = node_config_per_row

        cache_size = node_properties['cache_size'][0]
        node_config_per_row = []
        node_config_per_row.append(_('Cache Size'))
        node_config_per_row.append(cache_size)

        row_index += 1
        row_name = "row" + str(row_index)
        node_config_table[row_name] = node_config_per_row


        return node_config_table

    def get_configuration_fixedsizing(self):
        cluster_config_table = OrderedDict()
        cluster_properties = self.scenario_data['scenario_settings']

        threshold = cluster_properties['threshold']
        if threshold == 0:
            thr_value =  'Conservative'
        elif threshold == 1:
            thr_value = 'Standard'
        elif threshold == 2:
            thr_value = 'Aggressive'
        else:
            thr_value = 'Full Capacity'

        cluster_config_per_row = []
        cluster_config_per_row.append(_('Threshold'))
        cluster_config_per_row.append(_(thr_value))

        row_index = 0
        row_name = "row" + str(row_index)
        cluster_config_table[row_name] = cluster_config_per_row


        hypervisor = cluster_properties['hypervisor']
        if hypervisor == 'esxi':
            hypervisor_value = 'ESXi'
        else:
            hypervisor_value = 'Hyper-V'

        cluster_config_per_row = []
        cluster_config_per_row.append(_('Hypervisor'))
        cluster_config_per_row.append(hypervisor_value)

        row_index += 1
        row_name = "row" + str(row_index)
        cluster_config_table[row_name] = cluster_config_per_row


        hercules_conf = cluster_properties.get('hercules_conf', 'disabled')
        if hercules_conf == 'disabled':
            hercules_conf_value = 'Off'
        else:
            hercules_conf_value = 'On'

        cluster_config_per_row = []
        cluster_config_per_row.append(_('Hardware Acceleration'))
        cluster_config_per_row.append(_(hercules_conf_value))

        row_index += 1
        row_name = "row" + str(row_index)
        cluster_config_table[row_name] = cluster_config_per_row

        hx_boost_conf = cluster_properties.get('hx_boost_conf', 'disabled')
        if hx_boost_conf == 'disabled':
            hx_boost_conf_value = 'Off'
        else:
            hx_boost_conf_value = 'On'

        cluster_config_per_row = []
        cluster_config_per_row.append(_('HyperFlex Boost'))
        cluster_config_per_row.append(_(hx_boost_conf_value))

        row_index += 1
        row_name = "row" + str(row_index)
        cluster_config_table[row_name] = cluster_config_per_row

        return cluster_config_table


    def get_cluster_configuration_fixedsizing(self):
        cluster_config_table = OrderedDict()
        cluster_properties = self.scenario_data['scenario_settings']

        rf = cluster_properties['rf']
        self.rf = rf
        cluster_config_per_row = []
        cluster_config_per_row.append(_('Replication Factor'))
        cluster_config_per_row.append('RF' + str(rf))
        row_index = 0
        row_name = "row" + str(row_index)
        cluster_config_table[row_name] = cluster_config_per_row

        ft = cluster_properties['ft']
        self.ftnodes = ft
        cluster_config_per_row = []
        cluster_config_per_row.append(_('Performance Headroom'))
        cluster_config_per_row.append('N+' + str(ft))
        row_index += 1
        row_name = "row" + str(row_index)
        cluster_config_table[row_name] = cluster_config_per_row

        compression_factor = cluster_properties['compression_factor']
        self.compression_factor = compression_factor
        cluster_config_per_row = []
        cluster_config_per_row.append(_('Compression Savings(%)'))
        cluster_config_per_row.append(str(compression_factor))
        row_index += 1
        row_name = "row" + str(row_index)
        cluster_config_table[row_name] = cluster_config_per_row

        dedupe_factor = cluster_properties['dedupe_factor']
        self.dedupe_factor = dedupe_factor
        cluster_config_per_row = []
        cluster_config_per_row.append(_('Dedupe Savings(%)'))
        cluster_config_per_row.append(str(dedupe_factor))
        row_index += 1
        row_name = "row" + str(row_index)
        cluster_config_table[row_name] = cluster_config_per_row

        return cluster_config_table


    def renderSingleTable(self, slideObj, x, y, wid, heig, tabletitle, colWidth, tabledata):
        lentable = len(tabledata) -1
    
        slide = slideObj    
        shapes = slide.shapes
                
        rows = len(tabledata)
        cols = len(tabledata['header'])
        left = Inches(x)
        top = Inches(y)
        width = Inches(wid)
        height = Inches(heig)

        tbtop = top - Inches(0.64)
        txBox = slide.shapes.add_textbox(left, tbtop, Inches(2), Inches(1))
        tf = txBox.text_frame
        p = tf.add_paragraph()
        p.text = tabletitle
        p.font.bold = True
        p.font.size = Pt(12)
        p.font.color.rgb = RGBColor(0x92, 0xC8, 0xE9)

        table = shapes.add_table(rows, cols, left, top, width, height).table

        # set column widths
        for colindex in range(0, cols):
            table.columns[colindex].width = Inches(colWidth[colindex])

        for colindex in range(0, cols):
            table.cell(0, colindex).text = tabledata['header'][colindex]
            table.cell(0, colindex).text_frame.paragraphs[0].font.size=Pt(9)
            table.cell(0, colindex).text_frame.paragraphs[0].font.bold = True
            table.cell(0, colindex).fill.solid()
            table.cell(0, colindex).fill.fore_color.rgb = RGBColor(0xB2, 0xB2, 0xB2)

        for rowindex in range(0, lentable):
            for colindex in range(0, cols):
                key = 'row' + str(rowindex)
                table.cell(rowindex+1, colindex).text = tabledata[key][colindex]
                table.cell(rowindex+1, colindex).text_frame.paragraphs[0].font.size=Pt(8)

    def createFixedUserInputsPage(self):
        prs = self.prs
        slide = prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_BLANK_LAYOUT_INDEX])
        shapes = slide.shapes
        shapes.title.text = _('User Inputs')

        node_conf_table = self.get_node_configuration_fixedsizing()
        self.renderRectangleFixed(slide, node_conf_table)

        conf_table = self.get_configuration_fixedsizing()
        left = 0.29
        top = 3.5
        self.renderRectangle(slide, left, top, conf_table)

        cluster_conf_table = self.get_cluster_configuration_fixedsizing()
        left = 5.0
        top = 3.5
        self.renderRectangle(slide, left, top, cluster_conf_table)

    def renderTextBox(self, slide, left, top, width, height, value_text, tooltip, wrap=False):

        txBox = slide.shapes.add_textbox(left, top, width, height)
        txBox.text = value_text
        txBox.text_frame.paragraphs[0].font.size=Pt(20)
        txBox.text_frame.paragraphs[0].font.bold=True
        txBox.text_frame.paragraphs[0].font.name = 'CiscoSansTT Light'
        txBox.text_frame.paragraphs[0].alignment = PP_ALIGN.CENTER

        #left = left - Inches(0.3)
        ttop = top + Inches(0.5)
        txBox = slide.shapes.add_textbox(left, ttop, width, height)
        txBox.text = tooltip
        txBox.text_frame.paragraphs[0].font.size=Pt(10)
        txBox.text_frame.paragraphs[0].font.bold=False
        txBox.text_frame.paragraphs[0].font.name = 'CiscoSansTT Light'
        txBox.text_frame.paragraphs[0].alignment = PP_ALIGN.CENTER
        txBox.text_frame.word_wrap = wrap


    def createResultsPage(self):
        prs = self.prs
        slide = prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_FIVE_BOX_LAYOUT_INDEX])
        shapes = slide.shapes
        shapes.title.text = _('Sizing Calculator Report Results')

        cpu = slide.placeholders[10]
        memory = slide.placeholders[11]
        disk = slide.placeholders[12]
        iops = slide.placeholders[13]

        cpu.text  = " "
        memory.text = " "
        disk.text = " "
        iops.text = " "

        cores = self.scenario_data['results']['cores']
        cores_value = "{:,}".format(cores['pre_spec'])
        left = Inches(1.3)
        top = Inches(1.3)
        width = Inches(1.0)
        height = Inches(0.5)
        tooltip = _("Total Available Physical Cores") + "\n[" + _("equivalent to") + \
                  " {:,}".format(cores['post_spec']) + "\n Intel Platinum 8164 cores]"
        self.renderTextBox(slide, left, top, width, height, cores_value, tooltip)

        ram = self.scenario_data['results']['ram']
        left = Inches(3.5)
        top = Inches(1.3)
        width = Inches(3.0)
        height = Inches(0.5)
        units = "GiB"
        tooltip = _("Total Available Memory")
        ram_value = "{:,}".format(float(ram)) + " " + units
        self.renderTextBox(slide, left, top, width, height, ram_value, tooltip)

        total_iops = self.scenario_data['results']['iops']['total_iops'] \
            if 'iops' in self.scenario_data['results'] else "N/A"
        left = Inches(6.7)
        top = Inches(1.3)
        width = Inches(3.0)
        height = Inches(0.5)
        iops_value = total_iops
        tooltip = _("Total IOPS")
        self.renderTextBox(slide, left, top, width, height, iops_value, tooltip)

        usable_cap = self.scenario_data['results']['disk_capacity']['usable']
        left = Inches(1.3)
        top = Inches(3.5)
        width = Inches(1.0)
        height = Inches(0.5)
        units = self.scenario_data['results']['disk_capacity']['usable_unit']
        usable_binarybyte = self.scenario_data['results']['disk_capacity']['usable_binarybyte']
        usable_binaryunit = self.scenario_data['results']['disk_capacity']['usable_binaryunit']
        usable_value = "{:,}".format(float(usable_cap)) + " " + units + \
                       ' (' + "{:,}".format(float(usable_binarybyte)) + ' ' + str(usable_binaryunit) + ')'
        tooltip = _("Total Usable Capacity")
        self.renderTextBox(slide, left, top, width, height, usable_value, tooltip)


        effective_cap = self.scenario_data['results']['disk_capacity']['effective']

        compression = float(100 - self.compression_factor) / 100.0
        dedupe = float(100 - self.dedupe_factor) / 100.0
        scaling_factor = compression * dedupe
        effective_storage_savings = 100.0 /scaling_factor - 100
        effective_storage_savings = round(effective_storage_savings, 1)
        effective_storage_savings_mul = round((100 + effective_storage_savings)/100.0, 2)

        effective_cap_post_compression = round(float(usable_cap) / compression , 1)
        after = _('after')
        compressionstr = _("compression becomes")
        storage_saving_tip = "[%s %s %s %s%% %s\n %s / %s = %s %s\n" \
                               %(usable_cap, units, after, self.compression_factor, compressionstr, usable_cap,
                                 compression, effective_cap_post_compression, units)

        dedupestr = _("dedupe becomes")
        storage_saving_tip += "%s %s %s %s%% %s\n %s / %s = %s %s]" \
                               %(effective_cap_post_compression, units, after, self.dedupe_factor, dedupestr,
                                 effective_cap_post_compression, dedupe, effective_cap, units)

        left = Inches(3.5)
        top = Inches(3.5)
        width = Inches(3.0)
        height = Inches(0.5)
        units = self.scenario_data['results']['disk_capacity']['effective_unit']
        effective_binarybyte = self.scenario_data['results']['disk_capacity']['effective_binarybyte']
        effective_binaryunit = self.scenario_data['results']['disk_capacity']['effective_binaryunit']
        effective_value = "{:,}".format(float(effective_cap)) + " " + units + \
                          ' (' + "{:,}".format(float(effective_binarybyte)) + ' ' + str(effective_binaryunit) + ')'
        tooltip = _("Total Effective Capacity") + "\n" + storage_saving_tip
        self.renderTextBox(slide, left, top, width, height, effective_value, tooltip,wrap=True)


        available_cap = self.scenario_data['results']['disk_capacity']['available']
        left = Inches(6.7)
        top = Inches(3.5)
        width = Inches(3.0)
        height = Inches(0.5)
        units = self.scenario_data['results']['disk_capacity']['available_unit']
        available_binarybyte = self.scenario_data['results']['disk_capacity']['available_binarybyte']
        available_binaryunit = self.scenario_data['results']['disk_capacity']['available_binaryunit']
        available_value = "{:,}".format(float(available_cap)) + " " + units + \
                          ' (' + "{:,}".format(float(available_binarybyte)) + ' ' + str(available_binaryunit) + ')'
        tooltip = _("Best Threshold Practice")
        self.renderTextBox(slide, left, top, width, height, available_value, tooltip)

    # merge cells horizontally
    def mergeCellsHorizontally(self, table, row_idx, start_col_idx, end_col_idx):
        col_count = end_col_idx - start_col_idx + 1
        row_cells = [c for c in table.rows[row_idx].cells][start_col_idx:end_col_idx]
        row_cells[0]._tc.set('gridSpan', str(col_count))
        for c in row_cells[1:]:
            c._tc.set('hMerge', '1')

    def CreateNodeCalculationPage(self):

        CAPLIST = ['CPU', 'RAM', 'HDD']

        formulae = defaultdict(str)
        total_raw_capacity_prespec = defaultdict(int)
        total_raw_capacity = defaultdict(int)

        cpu_normalization = "NA"
        fault_tolerance = 1
        node_overhead = defaultdict(str)
        op_ratio = defaultdict(int)

        total_usable_capacity = defaultdict(int)
        node_reserve = defaultdict(str)
        total_available_capacity = defaultdict(int)
        total_effective_capacity = defaultdict(int)

        for cap in CAPLIST:
            op_ratio[cap] = 1

        total_nodes = self.no_of_nodes + self.no_of_computes
        for cap in CAPLIST:

            if cap == 'CPU':
                cpucores = self.scenario_data['results']['cores']
                speclnt = self.scenario_data['results']['cores']['speclnt']
                overhead = self.scenario_data['results']['overhead']['CPU']
                reservation = self.scenario_data['results']['reserve']['CPU']
                total_cores = cpucores['total_cores']

                formulae[cap] = "# (HX + Compute) Nodes * # Sockets * # of Cores"
                total_raw_capacity_prespec[cap] =  total_cores * total_nodes
                total_raw_capacity[cap] =  total_raw_capacity_prespec[cap] * speclnt

                cpu_normalization = self.cpu + ": " + str(round(speclnt, 2))
                node_overhead[cap] = str(overhead) + " pCPUs / node"
                nreserve = 100 - reservation * 100
                node_reserve[cap] = str(nreserve) + "%"

                total_cpu_overhead = overhead * self.no_of_nodes

                usable_capacity = total_raw_capacity[cap] - total_cpu_overhead
                total_usable_capacity[cap] = usable_capacity

                fault_tolerance_nodes = self.ftnodes
                available_capacity_per_hxnode = ((total_cores * speclnt) - overhead )
                available_capacity_per_computenode = total_cores * speclnt
                available_capacity = available_capacity_per_hxnode * (self.no_of_nodes - fault_tolerance_nodes) + \
                                     available_capacity_per_computenode * self.no_of_computes
                total_available_capacity[cap] = available_capacity

                total_effective_capacity[cap] = total_available_capacity[cap] * reservation
            elif cap == 'RAM':
                ramsize = self.ram
                overhead = self.scenario_data['results']['overhead']['RAM']
                reservation = self.scenario_data['results']['reserve']['RAM']

                formulae[cap] = "# (HX + Compute) Nodes * # DIMMs * DIMM Size"
                raw_capacity = ramsize * total_nodes
                total_raw_capacity[cap] += raw_capacity

                node_overhead[cap] = str(overhead)
                nreserve = 100 - reservation * 100
                node_reserve[cap] = str(nreserve) + "%"

                total_ram_overhead = overhead * self.no_of_nodes
                usable_capacity = total_raw_capacity[cap] - total_ram_overhead
                total_usable_capacity[cap] = usable_capacity

                fault_tolerance_nodes = self.ftnodes
                available_capacity = (ramsize - overhead) * (self.no_of_nodes - fault_tolerance_nodes) + \
                                     ramsize * self.no_of_computes
                total_available_capacity[cap] = available_capacity

                total_effective_capacity[cap] = total_available_capacity[cap] * reservation

            elif cap == 'HDD':

                hdd_size = self.disk_capacity / 1000.0      #Converting to TB
                total_hdd_size = hdd_size * self.disks_per_node
                overhead = self.scenario_data['results']['overhead']['HDD']
                reservation = self.scenario_data['results']['reserve']['HDD']
                replication_factor = self.rf

                formulae[cap] = "# HX Nodes * # Disk Slots * Disk Size"
                raw_capacity = total_hdd_size * self.no_of_nodes 
                total_raw_capacity[cap] += raw_capacity

                node_overhead[cap] = "8%"
                #node_overhead[cap] = str(overhead)
                nreserve = 100 - reservation * 100
                node_reserve[cap] = str(nreserve) + "%"

                #hdd_overhead = overhead
                hdd_overhead = 8 * total_hdd_size / 100.0
                usable_capacity_per_node = (total_hdd_size - hdd_overhead)
                total_usable_capacity[cap] = usable_capacity_per_node * self.no_of_nodes

                raw_capacity_after_rf = total_usable_capacity[cap] / replication_factor

                available_capacity = raw_capacity_after_rf * reservation
                total_available_capacity[cap] = available_capacity

                compression = float(100 - self.compression_factor) / 100.0
                dedupe = float(100 - self.dedupe_factor) / 100.0
                scaling_factor = compression * dedupe
                effective_storage_savings = 100.0 /scaling_factor - 100
                effective_storage_savings = round(effective_storage_savings, 1)
                effective_storage_savings_mul = round((100 + effective_storage_savings)/100.0, 2)

                effective_savings = (effective_storage_savings / 100.0) * total_available_capacity[cap] 
                total_effective_resource = round(total_available_capacity[cap] + effective_savings, 1)


        #Since this is lot customized table need to add here only, rather than calling general function.
        prs = self.prs
        slide = prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_BLANK_LAYOUT_INDEX])
        shapes = slide.shapes
        shapes.title.text = _('Node Calculation')

        rows = 11       # rows = 14
        cols = 8
        left = Inches(0.05)
        top = Inches(0.39)
        width = Inches(9.5)
        height = Inches(0.5)

        table = shapes.add_table(rows, cols, left, top, width, height).table

        # set column widths
        # set column widths
        for colindex in range(0, cols):
            table.columns[colindex].width = Inches(0.9)
            if colindex == 0:
                table.columns[colindex].width = Inches(1.0)
            if colindex == 6:
                table.columns[colindex].width = Inches(1.5)
            if colindex == 7:   #last column
                table.columns[colindex].width = Inches(2.9)

        # HEADER FORMATION
        row_index = 0
        table.cell(row_index, 0).text = ''
        table.cell(row_index, 1).text = _('Compute (Cores)')
        table.cell(row_index, 3).text = _('Memory (GiB)')
        table.cell(row_index, 5).text = _('Disk (TB/TiB)')
        table.cell(row_index, 7).text = _('Notes')

        for colindex in range(0, cols):
            table.cell(row_index, colindex).text_frame.paragraphs[0].font.size = Pt(9)
            table.cell(row_index, colindex).text_frame.paragraphs[0].font.bold = True
            table.cell(row_index, colindex).text_frame.paragraphs[0].alignment = PP_ALIGN.CENTER
            table.cell(row_index, colindex).fill.solid()
            table.cell(row_index, colindex).fill.fore_color.rgb = RGBColor(0xB2, 0xB2, 0xB2)

        # merge cells horizontally
        self.mergeCellsHorizontally(table=table, row_idx=row_index, start_col_idx=1, end_col_idx=2)
        self.mergeCellsHorizontally(table=table, row_idx=row_index, start_col_idx=3, end_col_idx=4)
        self.mergeCellsHorizontally(table=table, row_idx=row_index, start_col_idx=5, end_col_idx=6)

        for rowindex in range(1, rows):
            for colindex in range(0, cols):
                table.cell(rowindex, colindex).text_frame.paragraphs[0].font.size=Pt(7)
                table.cell(rowindex, colindex).text_frame.paragraphs[0].font.italic = True
                table.cell(rowindex, colindex).text_frame.paragraphs[0].alignment = PP_ALIGN.CENTER
                table.cell(rowindex, colindex).vertical_anchor = MSO_ANCHOR.MIDDLE


        #STARTING EACH ROWS ONE BY ONE..
        row_index += 1
        table.cell(row_index, 0).text = ''
        table.cell(row_index, 0).text_frame.paragraphs[0].font.bold = True
        table.cell(row_index, 0).text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
        table.cell(row_index, 1).text = _(formulae['CPU'])
        table.cell(row_index, 2).text = "{:,}".format(round(total_raw_capacity_prespec['CPU'], 1))
        table.cell(row_index, 3).text = _(formulae['RAM'])
        table.cell(row_index, 4).text = "{:,}".format(round(total_raw_capacity['RAM'], 1))
        table.cell(row_index, 5).text = _(formulae['HDD'])
        binary_unit = "{:,}".format(round(total_raw_capacity['HDD'] * HyperConstants.TB_TO_TIB_CONVERSION, 1))
        table.cell(row_index, 6).text = "{:,}".format(round(total_raw_capacity['HDD'], 1)) + \
                                        ' TB (' + binary_unit + ' TiB)'

        row_index += 1
        table.cell(row_index, 0).text = _('CPU Normalization')
        table.cell(row_index, 0).text_frame.paragraphs[0].alignment = PP_ALIGN.RIGHT
        table.cell(row_index, 1).text = _('Factor for ') + cpu_normalization
        table.cell(row_index, 2).text = "{:,}".format(round(total_raw_capacity['CPU'], 1))
        tooltip = \
            "Hx Sizer uses an Intel Platinum 8164 CPU as a baseline. Selected CPUs are normalized using the CPU SPEC " \
            "ratings against the baseline CPU"
        table.cell(row_index, 7).text = _(tooltip)
        table.cell(row_index, 7).text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
        table.cell(row_index, 7).text_frame.paragraphs[0].font.italic = False

        row_index += 1
        table.cell(row_index, 0).text = _('Total Physical Resources')
        table.cell(row_index, 0).text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
        table.cell(row_index, 0).text_frame.paragraphs[0].font.bold = True
        for colindex in range(0, cols):
            table.cell(row_index, colindex).fill.solid()
            table.cell(row_index, colindex).fill.fore_color.rgb = RGBColor(0xB0, 0xE0, 0xE6)
            table.cell(row_index, colindex).text_frame.paragraphs[0].font.italic = False
        table.cell(row_index, 1).text = "{:,}".format(round(total_raw_capacity['CPU'],1))
        table.cell(row_index, 3).text = "{:,}".format(round(total_raw_capacity['RAM'],1))
        binary_unit = "{:,}".format(round(total_raw_capacity['HDD'] * HyperConstants.TB_TO_TIB_CONVERSION, 1))
        table.cell(row_index, 5).text = "{:,}".format(round(total_raw_capacity['HDD'],1)) + \
                                        ' TB (' + binary_unit + ' TiB)'
        tooltip = _("Total physical resources available for sizing purposes")
        table.cell(row_index, 7).text = tooltip
        table.cell(row_index, 7).text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
        # merge cells horizontally
        self.mergeCellsHorizontally(table=table, row_idx=row_index, start_col_idx=1, end_col_idx=2)
        self.mergeCellsHorizontally(table=table, row_idx=row_index, start_col_idx=3, end_col_idx=4)
        self.mergeCellsHorizontally(table=table, row_idx=row_index, start_col_idx=5, end_col_idx=6)

        #row_index += 1  # Empty Row Needed??
        row_index += 1
        table.cell(row_index, 0).text = _("Controller VM & Metadata Reserves")
        table.cell(row_index, 0).text_frame.paragraphs[0].alignment = PP_ALIGN.RIGHT
        col = 1
        for cap in CAPLIST:
            table.cell(row_index, col).text = node_overhead[cap]
            col +=1
            if cap == 'HDD':
                binary_unit = "{:,}".format(round((total_usable_capacity[cap]-total_raw_capacity[cap]) *
                                        HyperConstants.TB_TO_TIB_CONVERSION, 1))
                table.cell(row_index, col).text = "{:,}".format(round(total_usable_capacity[cap]-total_raw_capacity[cap], 1)) + \
                                                  ' TB (' + binary_unit + ' TiB)'
            else:
                table.cell(row_index, col).text = "{:,}".format(round(total_usable_capacity[cap]-total_raw_capacity[cap], 1))
            col +=1

        tooltip = _("These are resourced used to run the HXDP stack that enables data services such as dedupe, " \
                  "compression, instantaneous snapshots, clones, etc.")
        table.cell(row_index, 7).text = tooltip
        table.cell(row_index, 7).text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
        table.cell(row_index, 7).text_frame.paragraphs[0].font.italic = False

        row_index += 1
        table.cell(row_index, 0).text = _("Overprovisioning/Replication Factor")
        table.cell(row_index, 0).text_frame.paragraphs[0].alignment = PP_ALIGN.RIGHT
        table.cell(row_index, 1).text = str(op_ratio['CPU'])
        table.cell(row_index, 2).text = "{:,}".format(round(total_usable_capacity['CPU'] * op_ratio['CPU'], 1))
        table.cell(row_index, 3).text = str(op_ratio['RAM'])
        table.cell(row_index, 4).text = "{:,}".format(round(total_usable_capacity['RAM'] * op_ratio['RAM'], 1))
        table.cell(row_index, 5).text = "RF" + str(replication_factor)
        binary_unit = "{:,}".format(round((raw_capacity_after_rf) * HyperConstants.TB_TO_TIB_CONVERSION, 1))
        table.cell(row_index, 6).text = "{:,}".format(round(raw_capacity_after_rf, 1)) + \
                                        ' TB (' + binary_unit + ' TiB)'
        tooltip = _("Overprovisioning includes CPU and RAM Overprovisioning Ratios.")
        tooltip += "\nRF" + str(replication_factor) + _(" ensures that data is available even after the cluster has " \
                       + str(replication_factor - 1) + " uncorrelated and simultaneous failures")
        table.cell(row_index, 7).text = tooltip
        table.cell(row_index, 7).text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
        table.cell(row_index, 7).text_frame.paragraphs[0].font.italic = False

        row_index += 1
        table.cell(row_index, 0).text = _("Performance headroom (N+X)")
        table.cell(row_index, 0).text_frame.paragraphs[0].alignment = PP_ALIGN.RIGHT
        col = 1
        for cap in ['CPU', 'RAM']:
            table.cell(row_index, col).text = 'N+' + str(fault_tolerance_nodes)
            col +=1
            table.cell(row_index, col).text = "{:,}".format(round(total_available_capacity[cap] -
                                                                  total_usable_capacity[cap], 1))
            col +=1

        tooltip = "N+X: This ensures there is enough performance capability to sustain applications after X failures"
        table.cell(row_index, 7).text = _(tooltip)
        table.cell(row_index, 7).text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
        table.cell(row_index, 7).text_frame.paragraphs[0].font.italic = False

        row_index += 1
        table.cell(row_index, 0).text = _('Total Usable')
        table.cell(row_index, 0).text_frame.paragraphs[0].font.bold = True
        table.cell(row_index, 0).text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
        for colindex in range(0, cols):
            table.cell(row_index, colindex).fill.solid()
            table.cell(row_index, colindex).fill.fore_color.rgb = RGBColor(0xB0, 0xE0, 0xE6)
            table.cell(row_index, colindex).text_frame.paragraphs[0].font.italic = False
        table.cell(row_index, 1).text = "{:,}".format(int(ceil(total_available_capacity['CPU'])))
        table.cell(row_index, 3).text = "{:,}".format(round(total_available_capacity['RAM'], 1))
        binary_unit = "{:,}".format(round(raw_capacity_after_rf * HyperConstants.TB_TO_TIB_CONVERSION, 1))
        table.cell(row_index, 5).text = "{:,}".format(round(raw_capacity_after_rf, 1)) + ' TB (' + binary_unit + ' TiB)'
        # merge cells horizontally
        self.mergeCellsHorizontally(table=table, row_idx=row_index, start_col_idx=1, end_col_idx=2)
        self.mergeCellsHorizontally(table=table, row_idx=row_index, start_col_idx=3, end_col_idx=4)
        self.mergeCellsHorizontally(table=table, row_idx=row_index, start_col_idx=5, end_col_idx=6)
        table.cell(row_index, 7).text = _('Total resources usable after accounting for controller VM overhead, ' \
                                        'and performance headroom')
        table.cell(row_index, 7).text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT

        row_index += 1
        table.cell(row_index, 0).text = _("Best Practice Threshold")
        table.cell(row_index, 0).text_frame.paragraphs[0].alignment = PP_ALIGN.RIGHT
        col = 1
        for cap in CAPLIST:
            table.cell(row_index, col).text = node_reserve[cap]
            col +=1
            if cap == 'HDD':
                binary_unit = "{:,}".format(round((total_available_capacity[cap] - raw_capacity_after_rf) *
                                        HyperConstants.TB_TO_TIB_CONVERSION, 1))
                table.cell(row_index, col).text = str(
                    round(total_available_capacity[cap] - raw_capacity_after_rf, 1)) + ' TB (' + binary_unit + ' TiB)'
            else:
                table.cell(row_index, col).text = "{:,}".format(round(total_effective_capacity[cap] -
                                                                      total_available_capacity[cap], 1))
            col +=1

        tooltip = _("CPU & Memory: This ensures predictable behavior for user VMs")
        if self.scenario_data['scenario_settings']['threshold'] == FULL_CAPACITY:
            tooltip +=  _(" and does not include reservations for the hypervisor.")

        tooltip += "\n" + _("Storage: Allows for better resilience and performance.")
        if self.scenario_data['scenario_settings']['threshold'] == FULL_CAPACITY:
            tooltip += "\n" + _("Hypervisor overheads must be accounted for separately.")

        table.cell(row_index, 7).text = tooltip
        table.cell(row_index, 7).text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
        table.cell(row_index, 7).text_frame.paragraphs[0].font.italic = False

        row_index += 1
        table.cell(row_index, 0).text = _("Storage Efficiency Savings Multiplier")
        table.cell(row_index, 0).text_frame.paragraphs[0].alignment = PP_ALIGN.RIGHT
        table.cell(row_index, 5).text = str(effective_storage_savings_mul)
        binary_unit = "{:,}".format(round(total_effective_resource * HyperConstants.TB_TO_TIB_CONVERSION, 1))
        table.cell(row_index, 6).text = "{:,}".format(total_effective_resource) + ' TB (' + binary_unit + ' TiB)'
        tooltip = _("This multiplier shows how much storage has increased " \
                  "due to Dedupe and Compression Savings")
        table.cell(row_index, 7).text = tooltip
        table.cell(row_index, 7).text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
        table.cell(row_index, 7).text_frame.paragraphs[0].font.italic = False

        row_index += 1
        table.cell(row_index, 0).text = _('Best Practice Resources')
        table.cell(row_index, 0).text_frame.paragraphs[0].font.bold = True
        table.cell(row_index, 0).text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
        for colindex in range(0, cols):
            table.cell(row_index, colindex).fill.solid()
            table.cell(row_index, colindex).fill.fore_color.rgb = RGBColor(0xB0, 0xE0, 0xE6)
            table.cell(row_index, colindex).text_frame.paragraphs[0].font.italic = False
        table.cell(row_index, 1).text = "{:,}".format(int(ceil(total_effective_capacity['CPU'])))
        table.cell(row_index, 3).text = "{:,}".format(round((total_effective_capacity['RAM']), 1))
        binary_unit = "{:,}".format(round(total_effective_resource * HyperConstants.TB_TO_TIB_CONVERSION, 1))
        table.cell(row_index, 5).text = "{:,}".format(total_effective_resource) + ' TB (' + binary_unit + ' TiB)'
        table.cell(row_index, 7).text = _('Includes Best Practice Not-to-Exceed Threshold')
        table.cell(row_index, 7).text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT

        # merge cells horizontally
        self.mergeCellsHorizontally(table=table, row_idx=row_index, start_col_idx=1, end_col_idx=2)
        self.mergeCellsHorizontally(table=table, row_idx=row_index, start_col_idx=3, end_col_idx=4)
        self.mergeCellsHorizontally(table=table, row_idx=row_index, start_col_idx=5, end_col_idx=6)
       
        #
        # return node_total_result, failure_capacity


    def renderRectangle(self, slideObj, left, top, tabledata):

        slide = slideObj
        shapes = slide.shapes
        
        left = Inches(left)
        actual_left = left
        top = Inches(top)
        width = Inches(2.0)
        height = Inches(0.3)

        tbleft = Inches(0.25)
        tbtop = Inches(3.12)
        tbwidth = Inches(2.7)
        tbheight = Inches(0.26)
        txBox = slide.shapes.add_textbox(tbleft, tbtop, tbwidth, tbheight)
        txBox.text = _('Cluster Properties')
        txBox.text_frame.paragraphs[0].font.size=Pt(12)
        txBox.text_frame.paragraphs[0].font.bold=True
        txBox.text_frame.paragraphs[0].font.color.rgb = RGBColor(0x92, 0xC8, 0xE9)

        #line = shapes.add_shape(MSO_SHAPE_TYPE.LINE, tbleft, Inches(0.93), tbwidth, 0)
        for rowindex in range(0, len(tabledata)):
            if rowindex % 2 == 0:
                RED = GREEN = BLUE = 0xF9
                                
            for colindex in range(0, len(tabledata['row0'])):
                key = 'row' + str(rowindex)
                shape = shapes.add_shape(MSO_SHAPE.RECTANGLE, left, top, width, height)
                shape.text_frame.paragraphs[0].font.size=Pt(9)
                shape.text_frame.paragraphs[0].font.color.rgb = RGBColor(0x00, 0x00, 0x00)
                fill = shape.fill
                fill.solid()
                fill.fore_color.rgb = RGBColor(RED, GREEN, BLUE)
                shape.text = tabledata[key][colindex]
                left = left + width + Inches(0.05)
            left = actual_left
            top = top + height + Inches(0.03)
            RED = GREEN = BLUE = 0xFF


    def renderRectangleFixed(self, slideObj, tabledata):

        slide = slideObj
        shapes = slide.shapes
        
        left = Inches(0.29)
        actual_left = left
        top = Inches(1.1)
        width = Inches(2.0)
        height = Inches(0.3)

        tbleft = Inches(0.25)
        tbtop = Inches(0.62)
        tbwidth = Inches(2.7)
        tbheight = Inches(0.26)
        txBox = slide.shapes.add_textbox(tbleft, tbtop, tbwidth, tbheight)
        txBox.text = _('Node Properties')
        txBox.text_frame.paragraphs[0].font.size=Pt(12)
        txBox.text_frame.paragraphs[0].font.name = 'CiscoSansTT Light'
        txBox.text_frame.paragraphs[0].font.bold=True
        txBox.text_frame.paragraphs[0].font.color.rgb = RGBColor(0x92, 0xC8, 0xE9)

        keys = ['row0', 'row1', 'row2', 'row3', 'row4']
        firsttabledata = {x:tabledata[x] for x in keys}

        for rowindex in range(0, len(firsttabledata)):
            if rowindex % 2 == 0:
                RED = GREEN = BLUE = 0xF9
                                
            for colindex in range(0, len(firsttabledata['row0'])):
                key = 'row' + str(rowindex)
                shape = shapes.add_shape(MSO_SHAPE.RECTANGLE, left, top, width, height)
                shape.text_frame.paragraphs[0].font.size=Pt(9)
                shape.text_frame.paragraphs[0].font.name = 'CiscoSansTT Light'
                shape.text_frame.paragraphs[0].font.color.rgb = RGBColor(0x00, 0x00, 0x00)
                fill = shape.fill
                fill.solid()
                fill.fore_color.rgb = RGBColor(RED, GREEN, BLUE)
                shape.text = firsttabledata[key][colindex]
                left = left + width + Inches(0.05)
            left = actual_left
            top = top + height + Inches(0.03)
            RED = GREEN = BLUE = 0xFF


        left = Inches(5.0)
        actual_left = left
        top = Inches(1.1)
        width = Inches(2.0)
        height = Inches(0.3)

        keys = ['row5', 'row6', 'row7', 'row8', 'row9']
        secondtabledata = {x:tabledata[x] for x in keys}

        for rowindex in range(5, len(tabledata)):
            if rowindex % 2 == 0:
                RED = GREEN = BLUE = 0xF9
                                
            for colindex in range(0, len(secondtabledata['row5'])):
                key = 'row' + str(rowindex)
                shape = shapes.add_shape(MSO_SHAPE.RECTANGLE, left, top, width, height)
                shape.text_frame.paragraphs[0].font.size=Pt(9)
                shape.text_frame.paragraphs[0].font.name = 'CiscoSansTT Light'
                shape.text_frame.paragraphs[0].font.color.rgb = RGBColor(0x00, 0x00, 0x00)
                fill = shape.fill
                fill.solid()
                fill.fore_color.rgb = RGBColor(RED, GREEN, BLUE)
                shape.text = secondtabledata[key][colindex]
                left = left + width + Inches(0.05)
            left = actual_left
            top = top + height + Inches(0.03)
            RED = GREEN = BLUE = 0xFF


    def createPageBreak(self, text):
        prs = self.prs
        slide = prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_BIG_STMT_LAYOUT_INDEX])
        shapes = slide.shapes
        title_shape = shapes.title
        title_shape.text = text

    def renderTableAcrossPages(self, slideTitle, x, y, wid, hei, colWidth, tabledata):
        prs = self.prs

        lentable = len(tabledata) - 1
                
        rowsPerSlide = 6
        if lentable % rowsPerSlide == 0:
            totalSlides = lentable / rowsPerSlide
        else:
            totalSlides = lentable / rowsPerSlide + 1
                
        slideNo = 1
              
        for rowindex in range(0, lentable):
            if rowindex % rowsPerSlide == 0:
                slide = prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_BLANK_LAYOUT_INDEX])
                shapes = slide.shapes

                slideNoPage = " (" + str(slideNo) + "/" + str(totalSlides) + ")"
                shapes.title.text = slideTitle + slideNoPage 
                slideNo += 1
                                
                # Add table
                rows = rowsPerSlide+1
                remainingRecords = lentable - rowindex
                if remainingRecords < rowsPerSlide:
                    rows=remainingRecords+1

                cols = len(tabledata['header'])
                left = Inches(x)
                top = Inches(y)
                width = Inches(wid)
                height = Inches(hei)

                table = shapes.add_table(rows, cols, left, top, width, height).table

                # set column widths
                for colindex in range(0, cols):
                    table.columns[colindex].width = Inches(colWidth[colindex])
                                
                for colindex in range(0, cols):
                    table.cell(0, colindex).text = tabledata['header'][colindex]
                    table.cell(0, colindex).text_frame.paragraphs[0].font.size=Pt(9)
                    table.cell(0, colindex).fill.solid()
                    table.cell(0, colindex).fill.fore_color.rgb = RGBColor(0xB2, 0xB2, 0xB2)


            rowPosition=(rowindex % rowsPerSlide)+1;
            
            for colindex in range(0, cols):
                key = 'row' + str(rowindex)
                table.cell(rowPosition, colindex).text = tabledata[key][colindex]
                table.cell(rowPosition, colindex).text_frame.paragraphs[0].font.size=Pt(8)


    def createglossaryPage(self):
        prs = self.prs

        glossary_path = os.path.join(BASE_DIR, "sizer/sizerglossary.txt")

        with open(glossary_path) as string_file:
            disclaimer_data=string_file.read()

        glossarydict = OrderedDict()
        glossarydict['header'] = ['Term', 'Definition']
        row_index = 0

        with open(glossary_path) as f:
            for line in f:
                if ':' in line:
                    (key, val) = line.split(':')
                    glossary_per_row = []
                    glossary_per_row.append(key)
                    output = val.replace('For example', '\n For example')
                    glossary_per_row.append(output)

                    row_name = "row" + str(row_index)
                    glossarydict[row_name] = glossary_per_row
                    row_index += 1

        # Coordinates for table
        x = 0.32    # LEFT POSITION
        y = 0.6            # TOP POSITION
        wid = 10    # table Width
        hei = 0.9       # height
        slideTitle = "Glossary"
        #colWidth = [1.3, 0.8, 5.3, 1.9]
        colWidth = [1.5, 7.5]

        self.renderTableAcrossPages(slideTitle, x, y, wid, hei, colWidth, glossarydict)


    def close(self):
        prs=self.prs

        # LAST SLIDE
        if self.language == JAPANESE:
            prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_LAST_LAYOUT_INDEX_JA])
        else:
            prs.slides.add_slide(prs.slide_layouts[PPTCALCReport.SLIDEMASTER_LAST_LAYOUT_INDEX])

        scenario_name = self.scenario_data['username'] + '_SizingCalculatorReport'
        currentdatetime= datetime.datetime.now().strftime('%Y-%m-%d_%H-%M')
        report_name = scenario_name + "_" + str(currentdatetime) + ".pptx"

        report_name = os.path.join(BASE_DIR, report_name)
        prs.save(report_name)

        return report_name


def GenerateSizingCalculatorReport(scenario_data, request_data):

    req_data = json.loads(request_data)
    language = req_data.get('language', ENGLISH)

    global _
    if language == JAPANESE:
        _ = languages[JAPANESE].gettext
        languages[JAPANESE].install()
    else:
        _ = languages[ENGLISH].gettext
        languages[ENGLISH].install()

    report = PPTCALCReport(scenario_data)
    report.language = language
    report.setup_calcreport()
    report.createHeaderPage()
    report.createAgendaPage()
    report.createOverviewPage()

    report.createPageBreak(_("Sizing Calculator Report"))

    report.createFixedUserInputsPage()
    report.createResultsPage()
    report.CreateNodeCalculationPage()

    ''' 
    report.createPageBreak("Backup")

    report.createglossaryPage()
    '''    

    report_path = report.close()
    return report_path


def SizingCalculatorReport(reportobj, calc_scenario_data):

    language = reportobj.language

    global _
    if language == JAPANESE:
        _ = languages[JAPANESE].gettext
        languages[JAPANESE].install()
    else:
        _ = languages[ENGLISH].gettext
        languages[ENGLISH].install()

    calcreport = PPTCALCReport(calc_scenario_data)
    calcreport.prs = reportobj.prs

    # calcreport.createPageBreak(_("Sizing Calculator Report"))

    calcreport.createFixedUserInputsPage()
    calcreport.createResultsPage()
    calcreport.CreateNodeCalculationPage()

    return
