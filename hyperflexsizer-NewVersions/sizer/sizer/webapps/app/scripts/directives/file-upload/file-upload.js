/* window._$clonedFile is using to decide whether to ignore the file selection on edit workload request */;
/* window._mpl_fileUploadData is using to decide whether to ignore the file selection on edit workload request */;

angular.module('hyperflex')
  .directive('fileUpload', ['$parse', "$http", "$sce", "$timeout", "APP_ENV", '$uibModal', function ($parse, $http, $sce, $timeout, APP_ENV, $uibModal) {

    function isSupportedFileFormat(fileName, supportedFilesFormat) {
      var format = null;
      var fname = fileName.toLowerCase();
      var fileExt = fname.substr(fname.lastIndexOf("."));
      return (supportedFilesFormat.indexOf(fileExt) !== -1)
    }

    /* directive definition */
    return {
      restrict: 'EA',
      templateUrl: "scripts/directives/file-upload/file-upload.html",
      scope: {
        onUploadSuccess: "&",
        onUploadError: "&",
        isProvisioned: "="
      },
      link: function (scope, element, attrs) {
        var vm = scope;
        vm.filetypeInput = "csv";
        vm.csvTooltip = "Supported CSV formats: CSV files generated by HX Workload Profiler";
        vm.xlsTooltip = "Supported Excel formats: Excel files generated by RV Tools"
        vm.csvFileAccept = ".csv";
        vm.xlsFileAccept = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel";
        vm.maxCSVFileSize = 1024 * 1024 * 50;//units will be in bytes (50 MB)
        vm.maxXLSFileSize = 1024 * 1024 * 50;//units will be in bytes (50 MB)
        vm.supportedFilesFormat = [".csv", ".xls", ".xlsx"];
        vm.selectedFile = null;
        vm.isFileSelected = false;
        vm.isFileHasPrasingError = true;
        vm.isFileHasPrased = false;
        vm.disableUPpload = true;
        vm.isInvalidFileFormat = false;
        vm.isBeyondMaxSize = false;
        vm.data = { 'isProvisioned': (vm.isProvisioned || false), 'typeSelected': 'host' };
        vm.fileOptions = [
          {
            key: "csv",
            value: "Sizer Upload Summary from HX Profiler"
          },
          {
            key: "xls",
            value: "RV Tools Output"
          }
        ];
        vm.fileUploadResponse;
        vm.clustersSelection = {
          title: "Select Cluster",
          options: [],
          model: [],
          disabledOptions: [],
          hiddenOptions: [],
          optionSuffix: '',
          includeSelectAll: true
        }
        vm.selectionOptionData = [];

        vm.tooltipContent = $sce.trustAsHtml("'Provisioned' will size for the provisioned CPU/Memory/Disk capacity of Hosts & VMs. <br> ‘Utilized’ will size for the actual utilized CPU/Memory/Disk capacity of Hosts & VMs; Utilized will usually be less than provisioned");
        vm.totalByTooltip = $sce.trustAsHtml("'This parameter will total resources by host level or by VM level. The VM level may not be representative of total resources on the host.'");

        vm.onClusterSelectionChanged = function ($event) {
          console.log('selectedOptions ', $event.selectedOptions);
          vm.selectionOptionData = $event.selectedOptions;
          if (vm.fileUploadResponse) {
            processResponse(vm.fileUploadResponse, $event.selectedOptions || []);

          }

        }

        vm.onInputFileTypeChanged = function () {
          if (vm.fileUploadResponse) {
            vm.confirmDialog().result.then(function (result) {
              vm.isFileSelected = false;
              vm.hasError = false;
              vm.hasWarning = false;
              vm.onClusterSelectionChanged({});
              vm.fileUploadResponse = null;
              clearFileData();
              $('#file_input').val(null);
            }, function () {
              // dismissed
              vm.filetypeInput = (vm.filetypeInput === 'csv') ? 'xls' : 'csv';
            });;
          }

        };

        vm.onFileSelectionChanged = function (fileElem) {
          vm.disableUPpload = false;
          vm.isFileHasPrasingError = false;
          vm.isFileHasPrased = false;
          vm.isInvalidFileFormat = false;
          vm.isBeyondMaxSize = false;
          vm.isFileSelected = fileElem.value && fileElem.value.length;// !(!fileElem.value)
          vm.hasError = false;
          vm.hasWarning = false;

          if (!vm.isFileSelected) {
            return scope.$apply();
          } else {
            vm.selectedFile = fileElem.files[0];
            if (!isSupportedFileFormat(vm.selectedFile.name, vm.supportedFilesFormat)) {
              vm.isInvalidFileFormat = true;
              scope.$emit("FORM_UPLOAD_ERROR", {
                data: {}
              });
              return scope.$apply();
            } else if ((vm.filetypeInput == "csv" && vm.selectedFile.size > vm.maxCSVFileSize) ||
              (vm.filetypeInput == "xls" && vm.selectedFile.size > vm.maxXLSFileSize)
            ) {
              vm.isBeyondMaxSize = true;
              scope.$emit("FORM_UPLOAD_ERROR", {
                data: {}
              });
              return scope.$apply();
            }

          }
          vm.selectedFile = fileElem.files[0];
          window._$clonedFile = element.find("input")[0].cloneNode();
          vm.uploadFile()
          scope.$apply();

          var fileType = (vm.filetypeInput == "csv" ? "HX Profiler CSV" : "RV Tools XLSX");


          scope.$emit("FILE_SELECTION_CHANGED", {
            data: { input_type: fileType }
          });
        }

        vm.onClick = function (e) {
          /*this is to clear the values on click & force the user to select the file with browse dialog box*/
          // $timeout(function(){
          //   e.target.value = "";
          //   $(e.target).trigger("change");
          // })
        };


        vm.confirmDialog = function () {
          return $uibModal.open({
            templateUrl: 'scripts/directives/file-upload/cluster_confirm.html',
            backdrop: 'static',
            size: 'sm',
            controller: 'WorkloadController',
            resolve: {
            }
          })
        }



        vm.onBasisSizingChanged = function () {
          if (vm.fileUploadResponse) {
            processResponse(vm.fileUploadResponse);
          }
        };

        vm.onTypeSizingChanged = function () {
          if (vm.fileUploadResponse) {
            processResponse(vm.fileUploadResponse);
          }
        };

        vm.uploadFile = function () {
          var fd = new FormData();
          fd.append('file', vm.selectedFile);
          var URL = APP_ENV.baseUrl + "/hyperconverged/processesxstat";
          var config = {
            url: URL,
            method: "POST",
            data: fd,
            transformRequest: angular.identity,
            headers: { 'Content-Type': undefined },
            progressbar: { id: 'file-upload-request' }
          };

          $http(config).success(function (response) {
            vm.hideOption = false;
            vm.data.typeSelected = 'host';
            saveFileData(response, null);
            vm.fileUploadResponse = response;
            vm.clustersSelection.model = [];
            processResponse(response);
            scope.$broadcast('SCENARIO_UPDATED');
          }).error(function (response) {
            clearFileData();
            vm.disableUPpload = false;
            vm.isFileHasPrasingError = true;
            vm.isFileHasPrased = true;

            scope.$emit("FORM_UPLOAD_ERROR", {
              data: response
            });
          });
        }

        vm.tooltipData = [
          "Error: No benchmark data for CPU: Intel E5-2650 in line 2 ",
          "Error: No benchmark data for CPU: Intel E5-2650 V4 in line 5 "
        ];

        function getClusterAggregate(clusterData) {
          return Object.keys(clusterData).reduce(function (hostData, hostName) {
            var key = hostData.hasOwnProperty('vm') ? 'vm' : 'host';
            if (hostData[key] && hostData[key].provisioned) {
              if (hostData['host'] && hostData['host'].provisioned) {
                Object.keys(hostData['host'].provisioned).forEach(function (propName) {
                  hostData['host'].provisioned[propName] += clusterData[hostName]['host'].provisioned[propName];
                  hostData['host'].utilized[propName] += clusterData[hostName]['host'].utilized[propName];
                })
              }
              if (hostData['vm'] && hostData['vm'].provisioned) {
                Object.keys(hostData['vm'].provisioned).forEach(function (propName) {
                  hostData['vm'].provisioned[propName] += clusterData[hostName]['vm'].provisioned[propName];
                  hostData['vm'].utilized[propName] += clusterData[hostName]['vm'].utilized[propName];
                })
              }
              return hostData;
            } else if (hostData.provisioned) {
              Object.keys(hostData.provisioned).forEach(function (propName) {
                hostData.provisioned[propName] += clusterData[hostName].provisioned[propName];
                hostData.utilized[propName] += clusterData[hostName].utilized[propName];
              })
              return hostData;
            } else {
              return clusterData[hostName];
            }
          }, {})
        }

        function limitToFixedDecimal(data) {
          Object.keys(data).forEach(function (propName) {
            data[propName] = data[propName].toFixed(1);
          })
        }

        function getDataForSelectedClusters(response, selectedClusters) {
          var clustersData = JSON.parse(JSON.stringify(response.data));
          var result;
          if (selectedClusters.length) {
            var clusterLevelData = selectedClusters.reduce(function (data, clusterName) {
              data[clusterName] = getClusterAggregate(clustersData[clusterName]);
              return data;
            }, {});

            var aggregateResult = getClusterAggregate(clusterLevelData);
            var aggrData;
            ['provisioned', 'utilized'].forEach(function (propName) {
              if (!aggregateResult.hasOwnProperty('vm')) {
                vm.hideOption = true;
              }
              // if (aggregateResult.hasOwnProperty('vm')) {
              //   aggrData = aggregateResult['vm'];
              //   aggrData[propName].vcpus_per_core = Math.ceil(aggrData[propName].vcpus / aggregateResult['host'][propName].vcpus);
              //   aggrData[propName].ram_opratio = Math.ceil(aggrData[propName].ram_size / aggregateResult['host'][propName].ram_size);
              // } else if (aggregateResult.hasOwnProperty('host')) {
              //   aggrData = aggregateResult['host'];
              //   aggrData[propName].vcpus_per_core = 1;
              //   aggrData[propName].ram_opratio = 1;
              // } 
              if (aggregateResult.hasOwnProperty(vm.data.typeSelected)) {
                aggrData = aggregateResult[vm.data.typeSelected];
                if (vm.data.typeSelected === 'vm') {
                  aggrData[propName].vcpus_per_core = Math.ceil(aggrData[propName].vcpus / aggregateResult['host'][propName].vcpus);
                  aggrData[propName].ram_opratio = Math.ceil(aggrData[propName].ram_size / aggregateResult['host'][propName].ram_size);
                } else {
                  aggrData[propName].vcpus_per_core = 1;
                  aggrData[propName].ram_opratio = 1;
                }
              } else {
                aggrData = aggregateResult;
                aggrData[propName].vcpus_per_core = 1;
                aggrData[propName].ram_opratio = 1;
              }
              limitToFixedDecimal(aggrData[propName]);
              // Backend will always sends data in GB units for hdd size
              // unit conversions
              if (vm.filetypeInput === 'csv') {
                if (aggrData[propName].hdd_size > 1000) {
                  aggrData[propName].hdd_size = (aggrData[propName].hdd_size / 1000).toFixed(1);
                  aggrData[propName].hdd_size_unit = 'TB'
                } else {
                  aggrData[propName].hdd_size_unit = 'GB'
                }
              } else {
                if (aggrData[propName].hdd_size > 1024) {
                  aggrData[propName].hdd_size = (aggrData[propName].hdd_size / 1024).toFixed(1);
                  aggrData[propName].hdd_size_unit = 'TiB'
                } else {
                  aggrData[propName].hdd_size_unit = 'GiB'
                }
              }


              if (aggrData[propName].ram_size > 1024) {
                aggrData[propName].ram_size = (aggrData[propName].ram_size / 1024).toFixed(1);
                aggrData[propName].ram_size_unit = 'TiB'
              } else {
                aggrData[propName].ram_size_unit = 'GiB'
              }
              // setting over-provisioning ratio to 1

              aggrData[propName].vcpus = Math.ceil(aggrData[propName].vcpus);
            });
            result = aggrData;
          } else {
            var clusterName = Object.keys(clustersData)[0];
            var hostName = Object.keys(clustersData[clusterName])[0];
            const clustData = clustersData[clusterName][hostName].hasOwnProperty('host') ? (clustersData[clusterName][hostName]['vm'] || clustersData[clusterName][hostName]['host']) : clustersData[clusterName][hostName];
            var sampleHostData = JSON.parse(JSON.stringify(clustData));
            Object.keys(sampleHostData.provisioned).forEach(function (prop) {
              sampleHostData.provisioned[prop] = null;
              sampleHostData.utilized[prop] = null;
            });
            sampleHostData.provisioned.vcpus_per_core = null;
            sampleHostData.utilized.vcpus_per_core = null;
            sampleHostData.hasDataInputError = true;
            result = sampleHostData;
          }

          saveFileData(response, selectedClusters);

          return result;
        }

        function saveFileData(response, selectedClusters) {
          window._mpl_fileUploadData = {
            selectedFile: vm.selectedFile,
            response: response,
            selectedClusters: selectedClusters
          };
        }

        function clearFileData() {
          window._mpl_fileUploadData = null;
        }

        function processResponse(response, selectedOptions) {
          vm.hasError = false;
          vm.hasWarning = false;
          vm.disableUPpload = false;
          vm.isFileHasPrasingError = false;
          vm.isFileHasPrased = true;

          // updating clusters list for the view
          vm.clustersSelection.options = Object.keys(response.data);
          if (!selectedOptions && vm.clustersSelection.model.length === 0) {
            vm.clustersSelection.model = vm.clustersSelection.options;
            vm.clustersSelection = vm.clustersSelection;
          }
          selectedOptions = selectedOptions || vm.clustersSelection.model;
          if (vm.selectionOptionData && vm.selectionOptionData.length !== selectedOptions.length) {
            // selectedOptions = vm.selectionOptionData;
            vm.selectionOptionData = selectedOptions;
          }

          if (response.status === "error") {
            vm.isFileHasPrasingError = true;
            vm.hasError = true;
            vm.tooltipData = response.Msg || []
            scope.$emit("FORM_UPLOAD_ERROR", {
              data: response
            });
          } else if (response.status === "warning") {
            vm.hasWarning = true;
            vm.tooltipData = response.Msg || []
            vm.isFileHasPrasingError = true;

            var aggregateData = getDataForSelectedClusters(vm.fileUploadResponse, selectedOptions);
            scope.$emit("FORM_UPLOAD_SUCCESS", {
              data: aggregateData,
              hasWarning: true,
              isProvisioned: vm.data.isProvisioned
            });
          } else if (response.status === "success") {
            var aggregateData = getDataForSelectedClusters(vm.fileUploadResponse, selectedOptions);
            vm.isFileHasPrasingError = false;
            scope.$emit("FORM_UPLOAD_SUCCESS", {
              data: aggregateData,
              isProvisioned: vm.data.isProvisioned
            });
          }


        }


        // initialize the data if file data exists
        if (window._mpl_fileUploadData) {
          vm.isFileSelected = true;
          vm.isFileHasPrasingError = false;
          vm.isFileHasPrased = true;

          vm.fileUploadResponse = window._mpl_fileUploadData.response;
          vm.onClusterSelectionChanged({ selectedOptions: window._mpl_fileUploadData.selectedClusters });
        }


      } //link function
    };


  }]);

